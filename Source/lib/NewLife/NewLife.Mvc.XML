<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NewLife.Mvc</name>
    </assembly>
    <members>
        <member name="T:NewLife.Mvc.GenericController">
            <summary>一般控制器</summary>
        </member>
        <member name="T:NewLife.Mvc.IController">
            <summary>控制器接口</summary>
        </member>
        <member name="M:NewLife.Mvc.IController.ProcessRequest(NewLife.Mvc.IRouteContext)">
            <summary>通过实现 <see cref="T:NewLife.Mvc.IController" /> 接口的自定义 Controller 启用 HTTP Web 请求的处理。</summary>
            <param name="context"><see cref="T:NewLife.Mvc.IRouteContext" /> 对象，它提供对用于为 HTTP 请求提供服务的内部服务器对象的引用。</param>
        </member>
        <member name="P:NewLife.Mvc.IController.IsReusable">
            <summary>获取一个值，该值指示其他请求是否可以使用 <see cref="T:NewLife.Mvc.IController" /> 实例。</summary>
            <returns>如果 <see cref="T:NewLife.Mvc.IController" /> 实例可再次使用，则为 true；否则为 false。</returns>
        </member>
        <member name="M:NewLife.Mvc.GenericController.Data(System.Object[])">
            <summary>使用指定的参数产生模版中使用的数据</summary>
            <example>
            一般用法:
            <code>
            Data(
                "keyname1", "value1", // 第一个必须是字符串
                "keyname2", "value2",
                "" // 会忽略没有成对出现的
            );
            </code>
            </example>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.GenericController.Data(System.Collections.Generic.IDictionary{System.String,System.Object},System.Object[])">
            <summary>向指定模版数据添加额外的,如果参数data为null会自动创建一个新的data,返回添加了数据的data</summary>
            <example>
            一般用法:
            <code>
            Data(dict,
                "newkeyname1", "value1", // 如果dict中已经包含newkeyname1则会覆盖
                ""
            );
            </code>
            </example>
            <param name="data"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.GenericController.Render(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>使用默认的模版生成页面</summary>
            <param name="data"></param>
        </member>
        <member name="M:NewLife.Mvc.GenericController.Render(System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>使用指定模版生成页面</summary>
            <param name="path">相对于模版路径的</param>
            <param name="data"></param>
        </member>
        <member name="M:NewLife.Mvc.GenericController.ProcessRequest(NewLife.Mvc.IRouteContext)">
            <summary>通过实现 <see cref="T:NewLife.Mvc.IController" /> 接口的自定义 Controller 启用 HTTP Web 请求的处理。</summary>
            <param name="context"><see cref="T:NewLife.Mvc.IRouteContext" /> 对象，它提供对用于为 HTTP 请求提供服务的内部服务器对象的引用。</param>
        </member>
        <member name="P:NewLife.Mvc.GenericController.Context">
            <summary>Http上下文</summary>
        </member>
        <member name="P:NewLife.Mvc.GenericController.Request">
            <summary>Http请求</summary>
        </member>
        <member name="P:NewLife.Mvc.GenericController.Response">
            <summary>Http响应</summary>
        </member>
        <member name="P:NewLife.Mvc.GenericController.Server">
            <summary>HttpServer</summary>
        </member>
        <member name="P:NewLife.Mvc.GenericController.Session">
            <summary>会话</summary>
        </member>
        <member name="P:NewLife.Mvc.GenericController.IsReusable">
            <summary>获取一个值，该值指示其他请求是否可以使用 <see cref="T:NewLife.Mvc.IController" /> 实例。</summary>
            <returns>如果 <see cref="T:NewLife.Mvc.IController" /> 实例可再次使用，则为 true；否则为 false。</returns>
        </member>
        <member name="T:NewLife.Mvc.GenericControllerFactory">
            <summary>一般控制器工厂接口</summary>
        </member>
        <member name="T:NewLife.Mvc.IControllerFactory">
            <summary>控制器工厂接口，用于创建控制器</summary>
            <remarks>因为需要针对每一次请求创建实例，而控制器工厂只需要一个即可，避免每次创建控制器都需要反射</remarks>
        </member>
        <member name="M:NewLife.Mvc.IControllerFactory.GetController(NewLife.Mvc.IRouteContext)">
            <summary>返回实现 <see cref="T:NewLife.Mvc.IController" /> 接口的类的实例。</summary>
            <returns>处理请求的新的 <see cref="T:NewLife.Mvc.IController" /> 对象。</returns>
            <param name="context"><see cref="T:NewLife.Mvc.IRouteContext" /> 类的实例，它提供对用于为 HTTP 请求提供服务的内部服务器对象的引用。</param>
        </member>
        <member name="M:NewLife.Mvc.IControllerFactory.ReleaseController(NewLife.Mvc.IController)">
            <summary>使工厂可以重用现有的控制器实例。</summary>
            <param name="handler">要重用的 <see cref="T:NewLife.Mvc.IController" /> 对象。</param>
        </member>
        <member name="M:NewLife.Mvc.GenericControllerFactory.ResolveTempletePath(System.String)">
            <summary>将指定的路径解析为模板文件物理路径,不检查文件是否存在</summary>
            <param name="path">以/ ~/ 或普通字符开始都可以</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.GenericControllerFactory.Support(System.String)">
            <summary>当前控制器工厂产生的控制器是否支持指定路径的请求</summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.GenericControllerFactory.GetController(NewLife.Mvc.IRouteContext)">
            <summary>返回实现 <see cref="T:NewLife.Mvc.IController" /> 接口的类的实例。</summary>
            <returns>处理请求的新的 <see cref="T:NewLife.Mvc.IController" /> 对象。</returns>
            <param name="context"><see cref="T:NewLife.Mvc.IRouteContext" /> 类的实例，它提供对用于为 HTTP 请求提供服务的内部服务器对象的引用。</param>
        </member>
        <member name="M:NewLife.Mvc.GenericControllerFactory.ReleaseController(NewLife.Mvc.IController)">
            <summary>使工厂可以重用现有的处理程序实例。</summary>
            <param name="handler">要重用的 <see cref="T:NewLife.Mvc.IController" /> 对象。</param>
        </member>
        <member name="P:NewLife.Mvc.GenericControllerFactory.TempleteDir">
            <summary>一般控制器的模版根目录,默认为网站根目录,即空白字符串,始终以普通字符开始,并且始终不以/符号结尾</summary>
        </member>
        <member name="P:NewLife.Mvc.GenericControllerFactory.AcceptSuffixs">
            <summary>一般控制器接受处理的请求后缀名,默认包含aspx,xt</summary>
        </member>
        <member name="T:NewLife.Mvc.GenericTemplateEngine">
            <summary>一般模版引擎XTemplate</summary>
            <remarks>
            默认通过快速反射调用XTemplate.Templating.Template.ProcessFile。
            可以通过重写Render改为调用XTemplate.Templating.Template.ProcessFile.ProcessTemplate，实现支持数据库模版等第三方模版源。
            </remarks>
        </member>
        <member name="T:NewLife.Mvc.ITemplateEngine">
            <summary>模版引擎接口</summary>
        </member>
        <member name="M:NewLife.Mvc.ITemplateEngine.Render(System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>生成页面</summary>
            <param name="templateName">模版文件名</param>
            <param name="data">参数数据</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Mvc.ITemplateEngine.Name">
            <summary>模版引擎名称</summary>
        </member>
        <member name="M:NewLife.Mvc.GenericTemplateEngine.Render(System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>生成页面</summary>
            <param name="templateName">模版文件名</param>
            <param name="data">参数数据</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Mvc.GenericTemplateEngine.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Mvc.GenericTemplateEngine.EngineType">
            <summary>XTemplate模版引擎类型</summary>
        </member>
        <member name="T:NewLife.Mvc.IgnoreRoute">
             <summary>
             忽略路由请求 后续的路由规则将不会尝试匹配 一般用于避免路由处理静态资源 在IIS设置为集成模式时
            
             在自定义的工厂内部需要忽略请求可以使用静态的Controller属性
             </summary>
        </member>
        <member name="M:NewLife.Mvc.IgnoreRoute.InstanceFunc">
            <summary>返回IgnoreRoute类的全局实例</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.IgnoreRoute.IsIgnore(NewLife.Mvc.IController)">
            <summary>返回指定控制器是否表示忽略请求,如果参数ctl为null也将返回true;</summary>
            <param name="ctl"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.IgnoreRoute.GetController(NewLife.Mvc.IRouteContext)">
            <summary>实现 IControllerFactory 接口</summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.IgnoreRoute.ReleaseController(NewLife.Mvc.IController)">
            <summary>实现 IControllerFactory 接口</summary>
            <param name="handler"></param>
        </member>
        <member name="P:NewLife.Mvc.IgnoreRoute.Controller">
            <summary>在自定义的工厂内部使用的,忽略请求</summary>
        </member>
        <member name="P:NewLife.Mvc.IgnoreRoute.Instance">
            <summary>IgnoreRoute类的全局实例</summary>
        </member>
        <member name="T:NewLife.Mvc.IgnoreRoute.IgnoreRouteController">
            <summary>忽略路由请求 的控制器</summary>
        </member>
        <member name="T:NewLife.Mvc.RedirectRoute">
            <summary>重定向工厂一般不需要自行实例化,使用RouteConfigManager.Redirect方法即可</summary>
        </member>
        <member name="M:NewLife.Mvc.RedirectRoute.#ctor(System.String,System.Boolean)">
            <summary>重定向到指定的路径,relativeRoot指定to是否是相对于服务器根路径(仅在to不是以~/开始的路径时)</summary>
            <param name="to"></param>
            <param name="relativeRoot"></param>
        </member>
        <member name="M:NewLife.Mvc.RedirectRoute.#ctor(NewLife.Reflection.Func{NewLife.Mvc.RouteContext,System.String,System.String})">
            <summary>重定向到指定委托返回的路径,其中委托参数string类型是IRouteContext.RoutePath从开始一直到当前路由模块匹配的路径</summary>
            <param name="func"></param>
        </member>
        <member name="M:NewLife.Mvc.RedirectRoute.GetController(NewLife.Mvc.IRouteContext)">
            <summary>实现IControllerFactory接口</summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RedirectRoute.ReleaseController(NewLife.Mvc.IController)">
            <summary>实现IControllerFactory接口</summary>
            <param name="handler"></param>
        </member>
        <member name="T:NewLife.Mvc.RedirectRoute.RedirectController">
            <summary>重定向控制器</summary>
        </member>
        <member name="M:NewLife.Mvc.RedirectRoute.RedirectController.ProcessRequest(NewLife.Mvc.IRouteContext)">
            <summary>实现重定向</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Mvc.StaticRoute">
            <summary>静态资源控制器工厂</summary>
        </member>
        <member name="M:NewLife.Mvc.StaticRoute.InstanceFunc">
            <summary>返回StaticRoute类的全局实例</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.StaticRoute.GetController(NewLife.Mvc.IRouteContext)">
            <summary>实现静态资源路由</summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.StaticRoute.ReleaseController(NewLife.Mvc.IController)">
            <summary>实现IControllerFactory接口</summary>
            <param name="handler"></param>
        </member>
        <member name="P:NewLife.Mvc.StaticRoute.Instance">
            <summary>StaticRoute类的全局实例</summary>
        </member>
        <member name="T:NewLife.Mvc.IRouteContext">
            <summary>运行时的路由上下文</summary>
        </member>
        <member name="M:NewLife.Mvc.IRouteContext.FindFrag(NewLife.Reflection.Func{NewLife.Mvc.RouteFrag,System.Boolean})">
             <summary>
             在Frags中查找第一个符合指定条件的RouteFrag
            
             匹配的Url片段将按照从右向左遍历,不同于Frags属性返回的是从左向右的
             </summary>
             <param name="filter"></param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.IRouteContext.FindAllFrag(NewLife.Reflection.Func{NewLife.Mvc.RouteFrag,System.Boolean})">
             <summary>
             在Frags中查找符合指定条件的RouteFrag
            
             匹配的Url片段将按照从右向左遍历,不同于Frags属性返回的是从左向右的
             </summary>
             <param name="filter"></param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.IRouteContext.RouteTo``1">
             <summary>
             路由当前路径到指定类的模块路由配置
            
             一般在控制器工厂中使用,用于运行时路由,相对应的是IRouteConfigModule配置路由
             </summary>
             <typeparam name="T"></typeparam>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.IRouteContext.RouteTo``1(System.String)">
             <summary>
             路由当前路径到指定类的模块路由配置
            
             一般在控制器工厂中使用,用于运行时路由,对应的静态路由是通过实现IRouteConfigModule接口配置路由
             </summary>
             <typeparam name="T"></typeparam>
             <param name="match">匹配到的路径,需要是当前Path属性的开始部分</param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.IRouteContext.RouteTo(System.Type)">
             <summary>
             路由当前路径到指定类型的模块路由配置
            
             一般在控制器工厂中使用,用于运行时路由,相对应的是IRouteConfigModule配置路由
             </summary>
             <param name="type">类型</param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.IRouteContext.RouteTo(System.String,System.Type)">
             <summary>
             路由当前路径到指定类型的模块路由配置
            
             一般在控制器工厂中使用,用于运行时路由,对应的静态路由是通过实现IRouteConfigModule接口配置路由
             </summary>
             <param name="match"></param>
             <param name="type">类型</param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.IRouteContext.RouteTo(System.String,NewLife.Mvc.ModuleRule)">
             <summary>
             路由当前路径到指定的模块路由规则
            
             一般在控制器工厂中使用,用于运行时路由,对应的静态路由是通过实现IRouteConfigModule接口配置路由
             </summary>
             <param name="match"></param>
             <param name="rule"></param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.IRouteContext.RouteTo(System.String,NewLife.Mvc.ModuleRule,NewLife.Reflection.Func{NewLife.Mvc.RouteFrag,NewLife.Mvc.RouteFrag})">
             <summary>
             路由当前路径到指定的模块路由规则
            
             一般在控制器工厂中使用,用于运行时路由,对应的静态路由是通过实现IRouteConfigModule接口配置路由
             </summary>
             <param name="match"></param>
             <param name="rule"></param>
             <param name="adjustRouteFrag">对路由上下文片段的微调回调,如果返回null则表示不进出路由上下文,如果指定为null则不做微调</param>
             <returns></returns>
        </member>
        <member name="P:NewLife.Mvc.IRouteContext.Path">
            <summary>
            当前的路径,在不同的上下文环境中有不同的含义
             在模块路由中:路由路径中,匹配当前模块后剩下的路径
             在控制器工厂中,路由路径中,匹配当前控制器工厂后剩下的路径
             在控制器中,路由路径中,匹配当前控制器后剩下的路径
            </summary>
        </member>
        <member name="P:NewLife.Mvc.IRouteContext.PathFragments">
            <summary>获取Path属性使用/分割后的片段,不包含空白的,对于/foo/bar.foo这样的路径,将会返回["foo","bar.foo"]</summary>
        </member>
        <member name="P:NewLife.Mvc.IRouteContext.RoutePath">
            <summary>当前路由处理的原始路径,完整的路径,从Url中网站根路径开始的</summary>
        </member>
        <member name="P:NewLife.Mvc.IRouteContext.Routed">
            <summary>当前Mvc路由是否已经路由到一个有效的控制器,忽略的路由IgnoreRoute不算有效的控制器</summary>
        </member>
        <member name="P:NewLife.Mvc.IRouteContext.Controller">
            <summary>返回路由最近的一个控制器,如果没有路由进控制器则返回null</summary>
        </member>
        <member name="P:NewLife.Mvc.IRouteContext.Factory">
            <summary>返回路由最近的一个控制器工厂,如果没有路由进工厂则返回null</summary>
        </member>
        <member name="P:NewLife.Mvc.IRouteContext.Module">
            <summary>返回路由最近的一个模块</summary>
        </member>
        <member name="P:NewLife.Mvc.IRouteContext.Config">
            <summary>当前路由最近的一个路由配置</summary>
        </member>
        <member name="P:NewLife.Mvc.IRouteContext.Frags">
             <summary>
             当前路由的片段,Url从左向右,分别表示数组下标从0开始的路由片段
            
             实现IEnumerable接口 遍历时也是如此的顺序
             </summary>
        </member>
        <member name="T:NewLife.Mvc.HttpCacheConfig">
             <summary>
             路由特定Http请求时的缓存配置
            
             HttpCachePolicy类型参数一般来自HttpResponse.Cache
             </summary>
        </member>
        <member name="M:NewLife.Mvc.HttpCacheConfig.RedirectCache(System.Web.HttpCachePolicy,System.Boolean)">
            <summary>重定向路由的缓存</summary>
            <param name="c"></param>
            <param name="isPermanently"></param>
        </member>
        <member name="M:NewLife.Mvc.HttpCacheConfig.NoCache(System.Web.HttpCachePolicy)">
            <summary>指定不缓存</summary>
            <param name="c"></param>
        </member>
        <member name="M:NewLife.Mvc.HttpCacheConfig.StaticCache(System.Web.HttpCachePolicy)">
            <summary>静态资源的缓存</summary>
            <param name="c"></param>
        </member>
        <member name="T:NewLife.Mvc.IRouteConfig">
            <summary>路由配置,默认会自动加载的路由配置</summary>
        </member>
        <member name="T:NewLife.Mvc.IRouteConfigModule">
            <summary>模块路由配置,可以在其它路由中</summary>
        </member>
        <member name="M:NewLife.Mvc.IRouteConfigModule.Config(NewLife.Mvc.RouteConfigManager)">
            <summary>配置方法</summary>
            <param name="cfg"></param>
        </member>
        <member name="T:NewLife.Mvc.RouteConfigManager">
            <summary>路由配置管理器</summary>
            <remarks>
            这个类是线程安全,如果会反复调用涉及到写的操作,建议使用AcquireWriterLock方法,可以避免反复的申请和释放写入锁
            </remarks>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.AcquireReaderLock``1(NewLife.Reflection.Func{``0},System.Boolean,System.Int32)">
            <summary>
            提供对Locker的简便访问方式,当获取到读取锁后回调指定的方法
            
            在外部调用这个方法可以避免当前类内部再度请求锁
            </summary>
            <param name="callback">当成功获取到锁时的回调</param>
            <param name="release">执行完callback是否自动释放锁</param>
            <param name="timeout">获取锁超时,如果发生超时则会抛出ApplicationException异常</param>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.AcquireWriterLock``1(NewLife.Reflection.Func{``0},System.Boolean,System.Int32)">
            <summary>
            提供对Locker的简便访问方式,当获取到读取锁后回调指定的方法
            
            在外部调用这个方法可以避免当前类内部再度请求锁
            </summary>
            <param name="callback">当成功获取到锁时的回调</param>
            <param name="release">执行完callback是否自动释放锁,只有在执行过获取锁才有可能释放</param>
            <param name="timeout">获取锁超时,如果发生超时则会抛出ApplicationException异常</param>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Route``1(System.String)">
            <summary>指定路径路由到指定控制器</summary>
            <typeparam name="T"></typeparam>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.RouteToFactory``1(System.String)">
            <summary>指定路径路由到控制器工厂,工厂是单例的</summary>
            <typeparam name="T"></typeparam>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.RouteToFactory(System.String,NewLife.Reflection.Func{NewLife.Mvc.IControllerFactory})">
            <summary>指定路径路由到控制器工厂,自定义工厂的初始化</summary>
            <param name="path"></param>
            <param name="newFunc">工厂实例化方式</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.RouteToModule``1(System.String)">
            <summary>指定路径路由到模块,模块是一个独立的路由配置,可以相对于自身所路由的路径,进一步路由到具体的控制器或者工厂</summary>
            <typeparam name="T"></typeparam>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Route(System.String,System.String)">
            <summary>指定路径路由到指定名称的类型,目标类型需要是IController,IControllerFactory,IRouteConfigMoudule其中之一</summary>
            <param name="path"></param>
            <param name="type">目标类型的完整名称,包括名称空间和类名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Route(System.String,System.Type)">
            <summary>指定路径路由到指定类型,类型需要是IController,IControllerFactory,IRouteConfigMoudule其中之一</summary>
            <param name="path"></param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Route(System.String,System.Type,System.Action{NewLife.Mvc.Rule})">
             <summary>
             指定路径路由到指定类型,类型需要是IController,IControllerFactory,IRouteConfigMoudule其中之一
            
             onCreatedRule在创建了路由规则后会调用,可用于对路由规则做细节调整
             </summary>
             <param name="path"></param>
             <param name="type">需要指定一个类型,可以是IController,IControllerFactory,IRouteConfigMoudule或其实现类型</param>
             <param name="onCreatedRule">根据Type类型的不同,参数可能是Rule或其子类FactoryRule,ModuleRule</param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Route(System.Object[])">
            <summary>指定多个路径路由到指定的目标,目标需要是IController,IControllerFactory,IRouteConfigMoudule其中之一</summary>
            <example>
            一般用法:
            <code>
            Route(
                "/foo", typeof(foo),
                "/bar", "namespaceName.bar",
                "" // 会忽略末尾不是成对出现的参数
            );
            </code>
            </example>
            <param name="args">多个路由规则,其中type可以是具体的Type或者字符串指定的类型名称</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Ignore(System.String[])">
             <summary>
             忽略指定路径的路由请求 后续的路由规则将不会尝试匹配 如果忽略的请求是静态资源请使用Static
            
             在Route(params object[] args) 中可以使用IgnoreRoute类来忽略路由请求
             </summary>
             <param name="path"></param>
             <returns></returns>
             <see cref="T:NewLife.Mvc.IgnoreRoute"/>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Ignore(System.String,NewLife.Reflection.Func{NewLife.Mvc.IRouteContext,System.Boolean})">
            <summary>将指定过滤器返回true的请求忽略 如果忽略的请求是静态资源请使用Static</summary>
            <param name="path"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Static(System.String[])">
            <summary>将指定路径作为静态资源路由 静态资源会在Http Header中增加相关的缓存标识 根据HttpCacheConfig</summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Static(System.String,NewLife.Reflection.Func{NewLife.Mvc.IRouteContext,System.Boolean})">
            <summary>将指定过滤器返回true的请求作为静态资源路由</summary>
            <param name="path"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Redirect(System.String,System.String)">
            <summary>重定向指定路径的请求到指定目标</summary>
            <param name="path">指定路径,当请求匹配当前模块的这个路径时重定向生效</param>
            <param name="to">重定向目标,相对于当前模块</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Redirect(System.String,System.String,System.Boolean)">
             <summary>
             重定向指定路径的请求到指定目标
            
             默认为301 Moved Permanently的重定向,并指定浏览器缓存
             </summary>
             <param name="path"></param>
             <param name="to">一般是相对于当前模块,以/开始,以~/开始的表示相对于当前web应用程序根路径</param>
             <param name="relativeRoot">指定to参数是否是相对于当前服务器根路径,to参数以~/开始时这个参数会被忽略</param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Redirect(System.String,NewLife.Reflection.Func{NewLife.Mvc.RouteContext,System.String,System.String})">
             <summary>
             重定向指定路径的请求到指定目标
            
             默认为302 Found的重定向,并指定浏览器不缓存
             </summary>
             <param name="path"></param>
             <param name="toFunc">根据条件重定向,需要返回重定向的目标地址,委托的第2个参数是当前路由上下文路由所有路由片段的地址</param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Load``1">
            <summary>加载指定模块类型的路由配置,不同于RouteToModule(string path),这个相当于IRouteConfigModule.Config(this)</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Load``1(``0@)">
             <summary>
             加载指定模块类型的路由配置,不同于RouteToModule(string path),这个相当于IRouteConfigModule.Config(this)
            
             其中module是创建的T类型的实例,全局单例的
             </summary>
             <typeparam name="T"></typeparam>
             <param name="module"></param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Load(System.Type)">
            <summary>加载指定模块类型的路由配置,不同于RouteToModule(string path),这个相当于IRouteConfigModule.Config(this)</summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Load(System.Type,NewLife.Mvc.IRouteConfigModule@)">
             <summary>
             加载指定模块类型的路由配置,不同于RouteToModule(string path),这个相当于IRouteConfigModule.Config(this)
            
             其中module是创建的type类型的实例,全局单例的
             </summary>
             <param name="type">类型</param>
             <param name="module">type参数的具体实例,如果未创建会为null</param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Load(NewLife.Mvc.IRouteConfigModule)">
            <summary>加载指定模块的路由配置,不同于RouteToModule(string path),这个相当于IRouteConfigModule.Config(this)</summary>
            <param name="module"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Sort">
            <summary>对路由规则进行排序 在使用这个路由配置前建议进行排序</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Sort(System.Boolean)">
            <summary>对路由规则进行排序 在使用这个路由配置前建议进行排序</summary>
            <param name="force">是否强制排序,一般使用false</param>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Route(System.String,System.Type,System.Type,NewLife.Reflection.Func{NewLife.Mvc.Rule,NewLife.Mvc.Rule})">
            <summary>最终添加路由配置的方法,上面的公共方法都会调用到这里</summary>
            <param name="path"></param>
            <param name="type">类型</param>
            <param name="ruleType">路由规则类型,未知类型使用null或者typeof(object)</param>
            <param name="onCreatedRule">创建路由规则后的回调,参数中包含刚创建的路由规则</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.StableSort``1(System.Collections.Generic.IList{``0},System.Boolean,System.Comparison{``0})">
            <summary>提供稳定排序,因为内部实现还是快速排序,所以需要指定isDesc参数</summary>
            <typeparam name="T"></typeparam>
            <param name="list">待排序的的列表,返回值也将是这个</param>
            <param name="isDesc">使用comp比较相同的元素是否使用和默认顺序相反的顺序排列,想保持默认顺序的话应使用false</param>
            <param name="comp"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.GetEnumerator">
            <summary>实现IList接口</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.System#Collections#IEnumerable#GetEnumerator">
            <summary>实现IList接口</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.IndexOf(NewLife.Mvc.Rule)">
            <summary>实现IList接口</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Insert(System.Int32,NewLife.Mvc.Rule)">
            <summary>实现IList接口</summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.RemoveAt(System.Int32)">
            <summary>实现IList接口</summary>
            <param name="index"></param>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Add(NewLife.Mvc.Rule)">
            <summary>实现IList接口</summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Clear">
            <summary>实现IList接口</summary>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Contains(NewLife.Mvc.Rule)">
            <summary>实现IList接口</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.CopyTo(NewLife.Mvc.Rule[],System.Int32)">
            <summary>实现IList接口</summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigManager.Remove(NewLife.Mvc.Rule)">
            <summary>实现IList接口</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Mvc.RouteConfigManager.Locker">
            <summary>
            路由配置管理内部的读写锁,一般建议使用当前类的AcquireReaderLock和AcquireWriterLock方法
            </summary>
        </member>
        <member name="P:NewLife.Mvc.RouteConfigManager.LoadModuleCache">
            <summary>加载模块的IRouteConfigModule实例缓存,Type为键,用于Load&lt;Type&gt;()和Load(Type type)方法</summary>
        </member>
        <member name="P:NewLife.Mvc.RouteConfigManager.Count">
            <summary>实现IList接口</summary>
        </member>
        <member name="P:NewLife.Mvc.RouteConfigManager.Item(System.Int32)">
            <summary>实现IList接口 get是可用的,set将抛出NotImplementedException异常,请使用Route方法系列或Load方法</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Mvc.RouteConfigManager.IsReadOnly">
            <summary>实现IList接口</summary>
        </member>
        <member name="T:NewLife.Mvc.RouteConfigException">
            <summary>路由配置异常</summary>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigException.#ctor(System.String)">
            <summary>构造方法</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Mvc.RouteConfigException.#ctor(System.String,System.String)">
            <summary>构造方法</summary>
            <param name="message"></param>
            <param name="paramName"></param>
        </member>
        <member name="P:NewLife.Mvc.RouteConfigException.Message">
            <summary>路由配置异常消息</summary>
        </member>
        <member name="T:NewLife.Mvc.RouteContext">
             <summary>
             路由的上下文信息
            
             上下文信息包括
               模块匹配的路径,路由到模块时会增加一个模块路径
               控制器工厂匹配的路径,路由到控制器工厂时会提供的值
               控制器匹配的路径,路由到控制器时会提供的值,如果是通过工厂路由到控制器的,那么和上一个工厂匹配的路径相同
               剩余的路径,其它情况下的路径
             </summary>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.#ctor(System.String)">
            <summary>构造方法,初始化一个路由上下文信息,指定初始的路由路径</summary>
            <param name="routePath"></param>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.FindFrag(NewLife.Reflection.Func{NewLife.Mvc.RouteFrag,System.Boolean})">
             <summary>
             在当前所有路由片段中查找第一个符合指定条件的路由片段
            
             匹配的Url片段将按照从右向左遍历,不同于Frags属性返回的是从左向右的
             </summary>
             <param name="filter"></param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.FindAllFrag(NewLife.Reflection.Func{NewLife.Mvc.RouteFrag,System.Boolean})">
             <summary>
             在当前所有路由片段中查找符合指定条件的所有路由片段
            
             匹配的Url片段将按照从右向左遍历,不同于Frags属性返回的是从左向右的
             </summary>
             <param name="filter"></param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.RouteTo``1">
             <summary>
             路由当前路径到指定类的模块路由配置
            
             一般在控制器工厂中使用,用于运行时路由,对应的静态路由是通过实现IRouteConfigModule接口配置路由
             </summary>
             <typeparam name="T"></typeparam>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.RouteTo``1(System.String)">
             <summary>
             路由当前路径到指定类的模块路由配置
            
             一般在控制器工厂中使用,用于运行时路由,对应的静态路由是通过实现IRouteConfigModule接口配置路由
             </summary>
             <typeparam name="T"></typeparam>
             <param name="match">匹配到的路径,需要是当前Path属性的开始部分</param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.RouteTo(System.Type)">
             <summary>
             路由当前路径到指定类的模块路由配置
            
             一般在控制器工厂中使用,用于运行时路由,对应的静态路由是通过实现IRouteConfigModule接口配置路由
             </summary>
             <param name="type">类型</param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.RouteTo(System.String,System.Type)">
             <summary>
             路由当前路径到指定类型的模块路由配置
            
             一般在控制器工厂中使用,用于运行时路由,对应的静态路由是通过实现IRouteConfigModule接口配置路由
             </summary>
             <param name="match"></param>
             <param name="type">类型</param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.RouteTo(System.String,NewLife.Mvc.ModuleRule)">
             <summary>
             路由当前路径到指定的模块路由规则
            
             一般在控制器工厂中使用,用于运行时路由,对应的静态路由是通过实现IRouteConfigModule接口配置路由
             </summary>
             <param name="match"></param>
             <param name="rule"></param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.RouteTo(System.String,NewLife.Mvc.ModuleRule,NewLife.Reflection.Func{NewLife.Mvc.RouteFrag,NewLife.Mvc.RouteFrag})">
             <summary>
             路由当前路径到指定的模块路由规则
            
             一般在控制器工厂中使用,用于运行时路由,对应的静态路由是通过实现IRouteConfigModule接口配置路由
             </summary>
             <param name="match"></param>
             <param name="rule"></param>
             <param name="adjustRouteFrag">对路由上下文片段的微调回调,如果返回null则表示不进出路由上下文,如果指定为null则不做微调</param>
             <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.EnterConfigManager(System.String,System.String,NewLife.Mvc.Rule,NewLife.Mvc.RouteConfigManager)">
            <summary>上下文进入特定路由配置</summary>
            <param name="match"></param>
            <param name="path"></param>
            <param name="r"></param>
            <param name="related"></param>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.ExitConfigManager(System.String,System.String,NewLife.Mvc.Rule,NewLife.Mvc.RouteConfigManager)">
            <summary>上下文退出特定路由配置</summary>
            <param name="match"></param>
            <param name="path"></param>
            <param name="r"></param>
            <param name="related"></param>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.EnterModule(System.String,System.String,NewLife.Mvc.Rule,NewLife.Mvc.IRouteConfigModule,NewLife.Reflection.Func{NewLife.Mvc.RouteFrag,NewLife.Mvc.RouteFrag})">
            <summary>上下文进入模块</summary>
            <param name="match">匹配到的路径,需要是Path参数的开始部分</param>
            <param name="path">进入模块前的路径</param>
            <param name="r">当前匹配的路由规则</param>
            <param name="related">模块实例</param>
            <param name="adjustRouteFrag">进入模块后调整路由上下文回调函数</param>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.ExitModule(System.String,System.String,NewLife.Mvc.Rule,NewLife.Mvc.IRouteConfigModule)">
            <summary>上下文退出模块</summary>
            <param name="match"></param>
            <param name="path"></param>
            <param name="r"></param>
            <param name="related"></param>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.EnterFactory(System.String,System.String,NewLife.Mvc.Rule,NewLife.Mvc.IControllerFactory)">
            <summary>上下文进入工厂</summary>
            <param name="match"></param>
            <param name="path"></param>
            <param name="r"></param>
            <param name="related"></param>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.ExitFactory(System.String,System.String,NewLife.Mvc.Rule,NewLife.Mvc.IControllerFactory)">
            <summary>上下文退出工厂</summary>
            <param name="match"></param>
            <param name="path"></param>
            <param name="r"></param>
            <param name="related"></param>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.EnterController(System.String,System.String,NewLife.Mvc.Rule,NewLife.Mvc.IController)">
            <summary>上下文进入控制器</summary>
            <param name="match"></param>
            <param name="path"></param>
            <param name="r"></param>
            <param name="related"></param>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.GetEnumerator">
            <summary>实现IEnumerable接口</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.RouteContext.ToString">
            <summary>
            重写,将输出
            {RouteContext 第1个路由片段信息
              =&gt; 第2个路由片段信息
              =&gt; 第n个路由片段信息}
            </summary>
            <returns></returns>
            <see cref="T:NewLife.Mvc.RouteFrag"/>
        </member>
        <member name="P:NewLife.Mvc.RouteContext.Current">
             <summary>
             当前请求路由上下文信息
            
             通过给当前属性赋值可以实现路由探测,即尝试匹配路由规则,但是不执行最终的控制器
             </summary>
        </member>
        <member name="P:NewLife.Mvc.RouteContext.RoutePath">
             <summary>
             当前请求的路由路径,即url排除掉当前应用部署的路径后,以/开始的路径,不包括url中?及其后面的
            
             路由操作主要是基于这个路径
            
             在当前请求初始化后不会改变
             </summary>
        </member>
        <member name="P:NewLife.Mvc.RouteContext.Routed">
            <summary>当前Mvc路由是否已经路由到一个有效的控制器,忽略的路由IgnoreRoute不算有效的控制器</summary>
        </member>
        <member name="P:NewLife.Mvc.RouteContext.Frags">
            <summary>当前路由的片段,Url从左向右,分别表示数组下标从0开始的路由片段</summary>
        </member>
        <member name="P:NewLife.Mvc.RouteContext.Config">
            <summary>当前路由最近的一个路由配置</summary>
        </member>
        <member name="P:NewLife.Mvc.RouteContext.Module">
            <summary>返回路由最近的一个模块</summary>
        </member>
        <member name="P:NewLife.Mvc.RouteContext.Factory">
            <summary>返回路由最近的一个控制器工厂,如果没有路由进工厂则返回null</summary>
        </member>
        <member name="P:NewLife.Mvc.RouteContext.Controller">
            <summary>返回路由最近的一个控制器,如果没有路由进控制器则返回null</summary>
        </member>
        <member name="P:NewLife.Mvc.RouteContext.Path">
            <summary>
            当前的路径,在不同的上下文环境中有不同的含义
             在模块路由中:路由路径中,匹配当前模块后剩下的路径
             在控制器工厂中,路由路径中,匹配当前控制器工厂后剩下的路径
             在控制器中,路由路径中,匹配当前控制器后剩下的路径
            </summary>
        </member>
        <member name="P:NewLife.Mvc.RouteContext.PathFragments">
            <summary>当前路径使用/分割后的片段,不包含空白的,对于/foo/bar.foo这样的路径,将会返回["foo","bar.foo"]</summary>
        </member>
        <member name="P:NewLife.Mvc.RouteContext.RouteToModuleCache">
            <summary>RouteTo(Type type)方法使用的缓存的RouteConfigManager,方便在工厂中使用,避免重复创建路由配置</summary>
        </member>
        <member name="T:NewLife.Mvc.RouteFrag">
            <summary>路由片段,表示当前请求路径每个匹配的路径信息</summary>
        </member>
        <member name="M:NewLife.Mvc.RouteFrag.ToString">
             <summary>
             重写,将会输出
             {RouteFrag 匹配到的原始路径 -&gt; 处理这个片段的实例 [片段类型] 匹配到的路由规则}
            
             其中"处理这个片段的实例"和"片段类型"有关,一般是IController IControllerFactory IRouteConfigModule RouteConfigManager的实例
             </summary>
             <returns></returns>
             <see cref="P:NewLife.Mvc.RouteFrag.Rule"/>
        </member>
        <member name="M:NewLife.Mvc.RouteFrag.GetRelated``1">
            <summary>返回当前片段关联对象的强类型实例,如果和指定类型不符则返回default(T)</summary>
            <typeparam name="T">一般是IController IControllerFactory IRouteConfigModule RouteConfigManager类型</typeparam>
            <returns></returns>
        </member>
        <member name="P:NewLife.Mvc.RouteFrag.Type">
            <summary>片段类型</summary>
        </member>
        <member name="P:NewLife.Mvc.RouteFrag.Path">
            <summary>片段匹配的实际路径</summary>
        </member>
        <member name="P:NewLife.Mvc.RouteFrag.Rule">
            <summary>片段匹配的路由规则实例</summary>
        </member>
        <member name="P:NewLife.Mvc.RouteFrag.Related">
            <summary>相关的对象,和Type关联</summary>
        </member>
        <member name="T:NewLife.Mvc.RouteFragType">
            <summary>路由片段类型</summary>
        </member>
        <member name="F:NewLife.Mvc.RouteFragType.Controller">
            <summary>控制器,Related是IController类型</summary>
        </member>
        <member name="F:NewLife.Mvc.RouteFragType.Factory">
            <summary>控制器工厂,Related是IControllerFactory类型</summary>
        </member>
        <member name="F:NewLife.Mvc.RouteFragType.Module">
            <summary>模块,Related是IRouteConfigModule类型</summary>
        </member>
        <member name="F:NewLife.Mvc.RouteFragType.Config">
            <summary>路由配置,Related是RouteConfigManager类型</summary>
        </member>
        <member name="T:NewLife.Mvc.Rule">
            <summary>路由规则</summary>
        </member>
        <member name="M:NewLife.Mvc.Rule.Create(System.String,System.Type,System.Type)">
            <summary>创建指定路径到指定类型的路由,路由类型由ruleType指定,如果未指定则会自动检测</summary>
            <param name="path"></param>
            <param name="type">类型</param>
            <param name="ruleType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.Rule.RouteTo(NewLife.Mvc.RouteContext)">
            <summary>路由当前上下文,子类根据自己的匹配逻辑重写</summary>
            <param name="ctx"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.Rule.TryMatch(System.String,System.String@)">
            <summary>使用当前路由规则的路径匹配指定的路径,返回是否匹配</summary>
            <param name="path"></param>
            <param name="match">返回匹配到的路径片段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Mvc.Rule.ToString">
            <summary>
            重写,将输出
            {Rule 规则配置的路径 -> 规则配置的目标类型}
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Mvc.Rule.Path">
             <summary>
             路由路径,赋值时如果以$符号结尾,表示是完整匹配(只会匹配Path部分,不包括Url中Query部分),而不是StartsWith匹配
            
             $$表示原始的$符号
             </summary>
        </member>
        <member name="P:NewLife.Mvc.Rule.Type">
            <summary>路由的目标类型,需要实现了IController,IControllerFactory,IRouteConfigMoudule任意一个</summary>
        </member>
        <member name="P:NewLife.Mvc.Rule.RuleTypeList">
            <summary>规则类型到具体类型的Rule子类映射</summary>
        </member>
        <member name="P:NewLife.Mvc.Rule.RuleTypeNames">
            <summary>RuleTypeList中所有规则类型名称,逗号分割的</summary>
        </member>
        <member name="T:NewLife.Mvc.Rule.RuleType">
            <summary>路由规则类型,及其对应的创建方法</summary>
        </member>
        <member name="F:NewLife.Mvc.Rule.RuleType.Type">
            <summary>路由规则类型</summary>
        </member>
        <member name="F:NewLife.Mvc.Rule.RuleType.New">
            <summary>对应规则的Rule实例创建方法</summary>
        </member>
        <member name="T:NewLife.Mvc.FactoryRule">
            <summary>工厂路由规则,会使用工厂的创建方法获取控制器,以及使用工厂的Support检查是否支持</summary>
        </member>
        <member name="M:NewLife.Mvc.FactoryRule.ToString">
            <summary>
            重写,将输出
            {FactoryRule 规则配置的路径 -> 规则配置的目标类型 目标工厂类型实例}
            其中"目标工厂类型实例"只有在不为null是输出
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Mvc.FactoryRule.NewFactoryFunc">
            <summary>工厂的创建方式,默认为直接创建Type指定的类型</summary>
        </member>
        <member name="P:NewLife.Mvc.FactoryRule.Factory">
            <summary>当前路由规则对应的控制器工厂实例</summary>
        </member>
        <member name="T:NewLife.Mvc.ModuleRule">
            <summary>模块路由规则,按需要初始化模块的路由配置,使用对应的RouteConfigManager路由请求</summary>
        </member>
        <member name="M:NewLife.Mvc.ModuleRule.ToString">
            <summary>
            重写,将输出
            {ModuleRule 规则配置的路径 -> 规则配置的目标类型 目标模块类型实例 模块产生的路由配置数量}
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Mvc.ModuleRule.Type">
            <summary>重写,路由目标类型</summary>
        </member>
        <member name="P:NewLife.Mvc.ModuleRule.Module">
            <summary>当前模块路由规则对应的模块</summary>
        </member>
        <member name="P:NewLife.Mvc.ModuleRule.Config">
            <summary>当前模块路由规则对应的路由配置</summary>
        </member>
        <member name="P:NewLife.Mvc.Service.Container">
            <summary>当前对象容器</summary>
        </member>
        <member name="T:NewLife.Mvc.Route">
             <summary>Url路由处理器</summary>
             <remarks>
            
             </remarks>
        </member>
        <member name="M:NewLife.Mvc.Route.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="M:NewLife.Mvc.Route.Init(System.Web.HttpApplication)">
            <summary>初始化仅执行一次,在不重新加载应用前</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Mvc.Route.LogException(System.Web.HttpResponse,System.Exception,System.String)">
             <summary>
             向指定Http响应写入异常标识信息,同时将异常以对应标识写入日志文件,方便根据异常标识查找异常信息
            
             只在生产环境下模式下返回true,打开调试开关将返回false,方便调试时查错
             </summary>
             <param name="resp"></param>
             <param name="ex"></param>
             <param name="exceptName"></param>
             <returns></returns>
        </member>
        <member name="P:NewLife.Mvc.Route.RootModule">
            <summary>根路由配置,自动加载实现了IRouteConfig接口的类中配置的路由规则</summary>
        </member>
        <member name="P:NewLife.Mvc.Route.Debug">
            <summary>控制器路由调试开关,打开将会在路由和控制器执行期间发生异常时输出详细的异常信息,默认为false</summary>
        </member>
        <member name="T:NewLife.Mvc.HttpHandlerWrap">
            <summary>将IController包装为IHttpHandler,用于给HttpContext.RemapHandler方法使用</summary>
        </member>
        <member name="M:NewLife.Mvc.HttpHandlerWrap.Create(NewLife.Mvc.IRouteContext,NewLife.Mvc.IController)">
            <summary>创建指定控制器实例的IHttpHandler包装实例,会根据需要创建可以读写Session的IHttpHandler实现</summary>
            <param name="context"></param>
            <param name="controller"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Mvc.HttpHandlerWrap.ReadOnlySession">
            <summary>提供只读访问HttpSession的HttpHandlerWrap子类</summary>
        </member>
        <member name="T:NewLife.Mvc.HttpHandlerWrap.ReadWriteSession">
            <summary>提供读写访问HttpSession的HttpHandlerWrap子类</summary>
        </member>
    </members>
</doc>
